diff --git a/src/nnn.c b/src/nnn.2pass.c
index 402d905..ec1600c 100644
--- a/src/nnn.c
+++ b/src/nnn.2pass.c
@@ -265,6 +265,12 @@ typedef struct entry {
 #endif
 } *pEntry;
 
+/* Selection marker */
+typedef struct {
+	char *startpos;
+	size_t len;
+} selmark;
+
 /* Key-value pairs from env */
 typedef struct {
 	int key;
@@ -402,7 +408,7 @@ static int nselected;
 #ifndef NOFIFO
 static int fifofd = -1;
 #endif
-static uint_t idletimeout, selbufpos, lastappendpos, selbuflen;
+static uint_t idletimeout, selbufpos, selbuflen;
 static ushort_t xlines, xcols;
 static ushort_t idle;
 static uchar_t maxbm, maxplug;
@@ -806,6 +812,7 @@ static int set_sort_flags(int r);
 #ifndef NOFIFO
 static void notify_fifo(bool force);
 #endif
+static int markcmp(const void *va, const void *vb);
 
 /* Functions */
 
@@ -1469,8 +1476,6 @@ static void startselection(void)
 			writesel(NULL, 0);
 			selbufpos = 0;
 		}
-
-		lastappendpos = 0;
 	}
 }
 
@@ -1488,33 +1493,99 @@ static size_t appendslash(char *path)
 	return len;
 }
 
-static void invertselbuf(char *path, bool toggle)
+static char *findinsel(int len)
 {
-	selbufpos = lastappendpos;
+	if (!selbufpos)
+		return FALSE;
 
-	if (toggle || nselected) {
-		size_t len = appendslash(path);
+	char *found = pselbuf;
+	do {
+		/* memmem(3):
+		 * This function is not specified in POSIX.1, but is present on a number of other systems.
+		 */
+		memmem(found, selbufpos - (found - pselbuf), g_buf, len);
+	} while (found > pselbuf && *(found - 1) == '\0');
+	return found;
+}
+
+static void invertselbuf(char *path)
+{
+	if (nselected) {
+		size_t len;
+		char *found;
+		int nmarked = 0, prev = 0;
+		selmark *marked = malloc(nselected * sizeof(selmark));
 
 		for (int i = 0; i < ndents; ++i) {
-			if (toggle) { /* Toggle selection status */
-				pdents[i].flags ^= FILE_SELECTED;
-				pdents[i].flags & FILE_SELECTED ? ++nselected : --nselected;
+			 /* Toggle selection status */
+			pdents[i].flags ^= FILE_SELECTED;
+			pdents[i].flags & FILE_SELECTED ? ++nselected : --nselected;
+		}
+
+		for (int i = 0; i < ndents; ++i){
+			/* Find no longer selected */
+			if(pdents[i].flags & FILE_SELECTED)
+				continue;
+
+			len = mkpath(path, pdents[i].name, g_buf);
+			found = findinsel(len);
+
+			if (found) {
+				marked[nmarked].startpos = found;
+				marked[nmarked].len = len;
+				++nmarked;
 			}
+		}
+
+		/* Remove no longer selected */
+		qsort(marked, nmarked, sizeof(selmark), &markcmp);
+
+		for (int i = 1; i < nmarked; ++i) {
+			if (marked[i].startpos == marked[prev].startpos + marked[prev].len)
+				marked[prev].len += marked[i].len;
+			else
+				++prev;
+		}
 
-			if (pdents[i].flags & FILE_SELECTED)
-				appendfpath(path,
-					len + xstrsncpy(path + len, pdents[i].name, PATH_MAX - len));
+		nmarked = prev + 1;
+
+		for (int i = 0; i < nmarked; ++i) {
+			found = marked[i].startpos;
+			len = marked[i].len;
+
+			memmove(found, found+len, selbufpos - ((found+len) - pselbuf));
+			selbufpos -= len;
 		}
 
-		if (len > 1)
-			--len;
-		path[len] = '\0';
+		free(marked);
+
+		/* Add newly selected */
+		for (int i = 0; i < ndents; ++i) {
+			if(!(pdents[i].flags & FILE_SELECTED))
+				continue;
+
+			len = mkpath(path, pdents[i].name, g_buf);
+			appendfpath(g_buf, len);
+		}
 
 		nselected ? writesel(pselbuf, selbufpos - 1) : writesel(NULL, 0);
 	} else
 		writesel(NULL, 0);
 }
 
+/* removes g_buf from selbuf */
+static void rmfromselbuf(size_t len)
+{
+	char *found = findinsel(len);
+	if (!found)
+		return;
+
+	memmove(found, found+len, selbufpos - ((found+len) - pselbuf));
+	selbufpos -= len;
+
+	nselected ? writesel(pselbuf, selbufpos - 1) : writesel(NULL, 0);
+}
+
 static void addtoselbuf(char *path, int startid, int endid)
 {
 	size_t len = appendslash(path);
@@ -2601,6 +2672,14 @@ static void clearfilter(void)
 	}
 }
 
+static int markcmp(const void *va, const void *vb)
+{
+	const selmark *ma = (selmark*)va;
+	const selmark *mb = (selmark*)vb;
+
+	return ma->startpos - mb->startpos;
+}
+
 static int entrycmp(const void *va, const void *vb)
 {
 	const struct entry *pa = (pEntry)va;
@@ -5283,6 +5362,9 @@ static int dentfill(char *path, struct entry **ppdents)
 			entflags = 0;
 		}
 
+		if (findinsel(mkpath(path, dentp->name, g_buf)) != NULL)
+			dentp->flags |= FILE_SELECTED;
+
 		if (cfg.blkorder) {
 			if (S_ISDIR(sb.st_mode)) {
 				mkpath(path, namep, buf);
@@ -5552,9 +5634,6 @@ static int handle_context_switch(enum action sel)
 			else
 				return -1;
 		}
-
-		if (g_state.selmode) /* Remember the position from where to continue selection */
-			lastappendpos = selbufpos;
 	}
 
 	return r;
@@ -6128,9 +6207,6 @@ begin:
 	}
 #endif
 
-	if (g_state.selmode && lastdir[0])
-		lastappendpos = selbufpos;
-
 #ifdef LINUX_INOTIFY
 	if ((presel == FILTER || watch) && inotify_wd >= 0) {
 		inotify_rm_watch(inotify_fd, inotify_wd);
@@ -6213,9 +6289,6 @@ nochange:
 				if (r >= CTX_MAX)
 					sel = SEL_BACK;
 				else if (r >= 0 && r != cfg.curctx) {
-					if (g_state.selmode)
-						lastappendpos = selbufpos;
-
 					savecurctx(&cfg, path, pdents[cur].name, r);
 
 					/* Reset the pointers */
@@ -6791,7 +6864,7 @@ nochange:
 				writesel(pselbuf, selbufpos - 1); /* Truncate NULL from end */
 			} else {
 				--nselected;
-				invertselbuf(path, FALSE);
+				rmfromselbuf(mkpath(path, pdents[cur].name, g_buf));
 			}
 
 #ifndef NOX11
@@ -6862,7 +6935,7 @@ nochange:
 				selendid = ndents - 1;
 			}
 
-			(sel == SEL_SELINV) ? invertselbuf(path, TRUE) : addtoselbuf(path, selstartid, selendid);
+			(sel == SEL_SELINV) ? invertselbuf(path) : addtoselbuf(path, selstartid, selendid);
 
 #ifndef NOX11
 			if (cfg.x11)
